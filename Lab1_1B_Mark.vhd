
---------------------------------------------------------
--  This code is generated by Terasic System Builder
---------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity Lab1_1A is
port
(

	------------ CLOCK ------------
--	CLOCK2_50       	:in    	std_logic;
--	CLOCK3_50       	:in    	std_logic;
--	CLOCK4_50       	:in    	std_logic;
--	CLOCK_50        	:in    	std_logic;

	------------ KEY ------------
	KEY             	:in    	std_logic_vector(3 downto 0);

	------------ SW ------------
	SW              	:in    	std_logic_vector(9 downto 0);

	------------ LED ------------
	LEDR            	:out   	std_logic_vector(9 downto 0);

	------------ Seg7 ------------
	HEX0            	:out   	std_logic_vector(6 downto 0);
	HEX1            	:out   	std_logic_vector(6 downto 0);
	HEX2            	:out   	std_logic_vector(6 downto 0);
	HEX3            	:out   	std_logic_vector(6 downto 0);
	HEX4            	:out   	std_logic_vector(6 downto 0);
	HEX5            	:out   	std_logic_vector(6 downto 0)
);

end entity;



---------------------------------------------------------
--  Structural coding
---------------------------------------------------------


architecture rtl of Lab1_1A is
component Dflipflop is
port
(
	--INPUTS
	CLK, RST, D, E    : in std_logic;
	--OUTPUTS
	Q     : out std_logic
);
end component Dflipflop;

	signal D, Q : std_LOGIC_VECTOR(8 downto 0);
	signal CLOCK, Reset, nReset, w, y: std_logic;

begin
	
	CLOCK <= KEY(0);
	Reset <= SW(0);
	w <= SW(1);
	
	nReset <= not SW(0);
	
	-- I
	D(8) <= w AND (Q(7) OR Q(1) OR Q(2) OR Q(3) OR Q(4) OR Q(5) OR Q(6));
	bit8 : Dflipflop 
	port map(CLOCK, Reset, D(8), '1', Q(8), D(0), '1', Q(0));
	
	-- H
	D(7) <= w AND (Q(6) OR Q(1) OR Q(2) OR Q(3) OR Q(4) OR Q(5));
	bit7 : Dflipflop
	port map(CLOCK, Reset, D(7), '1', Q(7), D(0), '1', Q(0));
	
	-- G
	D(6) <= w AND (Q(5) OR Q(1) OR Q(2) OR Q(3) OR Q(4));
	bit6 : Dflipflop
	port map(CLOCK, Reset, D(6), '1', Q(6), D(0), '1', Q(0));
	
	-- F
	D(5) <= w AND (Q(0) OR Q(1) OR Q(2) OR Q(3) OR Q(4));
	bit5 : Dflipflop
	port map(CLOCK, Reset, D(5), '1', Q(5), D(0), '1', Q(0));

	-- E
	D(4) <= not(w) AND (Q(3) OR Q(2) OR Q(1));
	bit4 : Dflipflop
	port map(CLOCK, Reset, D(4), '1', Q(4), D(0), '1', Q(0));
	
	-- D
	D(3) <= not(w) AND (Q(1) OR Q(2));
	bit3 : Dflipflop
	port map(CLOCK, Reset, D(3), '1', Q(3), D(0), '1', Q(0));
	
	-- C
	D(2) <= not(w) AND Q(1);
	bit2 : Dflipflop
	port map(CLOCK, Reset, D(2), '1', Q(2), D(0), '1', Q(0));
	
	-- B
	D(1) <= not(w) AND (Q(4) OR Q(5) OR Q(6) OR Q(7) OR Q(8));
	bit1 : Dflipflop
	port map(CLOCK, Reset, D(1), '1', Q(1), D(0), '0', Q(0));
	
	-- A
	D(0) <= '1';
	bit0 : Dflipflop
	port map(CLOCK, nReset, D(0), '0', Q(0));
	
	LEDR(8 downto 0) <= Q(8 downto 0);
	
	y <= Q(4) OR Q(8);
	LEDR(9) <= y;

end rtl;

